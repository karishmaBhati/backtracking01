<!DOCTYPE html>
<html lang="en">
<head>

    <title>Backtracking Project</title>

<hr/>
</head>

<body>
    <h1>Backtracking</h1><br />
    <p>Backtracking is a form of recursion</P>
    <p>The usual scenario is that you are faced with a njmber of option,and you must choose one of these.After you make your choices you will get a new set of options;just set of options depends on what choiceyou made.This procedure isrepeated over and over until you reach a final state .IF you made a good sequences of choices,your finalstate os goal state ;if you didn't, it isn't. </p>
    <br>
    
    <p>Conceptually,you start at root of tree probably have some good leaves and some bad leaves,though it may be that 
        the leave are all good or bad.want to get agood leaf.At each node,begning with the root,you choose one of its 
        children to move to,and you keep this much until you get to a leaf.
    </p>
    <br>
    
    <p>suppose you get a bad leaf. You can backtrack the continue search for a good leaf by revoking your most recent choice,
        and trying out the next option in that set of options.if you run out of options revoke the choice that got you here ,and try 
        another choice at the node .If you end up bhy the root with no options left ,there are no good leaves to be founded
    </p>
    <br>
     <p>This needs an example:-</p>
     <img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\image root.png" width="200px" height="200px">
     <br>
     <br>

</body>
<ol type="1">
    <li>Starting at root , your option are A and B </li>
    <li>At A , your option are C and D , you choose C</li>
    <li>C is bad , Go to A</li>
    <li>At A you have already tried C , and its fail . Try D</li>
    <li>D is bad Go to A .</li>
    <li>A , ypu have no ooption left to try . Go backnto root</li>
    <li>At Root you have already tried A try B .</li>
    <li>At B , your option are E and F . Try E</li>
    <li>E is good Congratulations</li>
    </ol>
    

    <Div class="box1">
        <p>In this example we drew a picture of tree . The tree is the abstract modelof the possible sequence of choices we could make.There is also a data structure called a tree,but usually we don't have adata structure to tell us what choices we have.(if we have an actual tree data structure,backtracking on itd called depth-first tree searching.)</p>
        
    </Div>
    <hr>
    <h2>The Backtracking ALgorithm</h2>
</hr>
<br>
<Div>
    <font color="blue">
    <pre>
        boolean solve(Node n){
            if  n is leaf node{
                if leaf is a goal node, return true
                else return false 
              } else {
                for each child c of n{
                    if solve c succeeds,return true
                }
                return false
              }
        }
    
    </pre>
    </font>
    </Div>

</Div>
<p>Notice that a algorithm is expressed the boollean function.Thus is essential for understanding the algorithm.if solve(n)is true,that means node n is apart of solution--that is,node n is one of the nodes on path from the root to some goal node.we say that n is solvable. If solve(n) isa false, then there is no path path that includes n to any goal node.</p>
    <br>
<h3>How does it works?</h3>
<ul>
<li>if any child of n is solvable, then n is solvable.</li>
<li>if no child of n is solvable, then n is not solvable</li>
</ul>

<p>Hence,to decide whether any non-leaf node n is solvable(paprt of a pathto a goal node),all you have to do is test whether anychild of n is solvable.This is done recursively,on each child of n .In the above code this is done by the lines.
</p>
<font color="blue">
<pre>

for each child c of n {
    if solve(c) succeedes,return true
}
return false

</pre>
</font>

<p>Eventually the recursion will "buttom" out at a leaf node is agoal node, it is solvable,if the leaf node is not goal node,if it is not solvable.This is our base case.In the above code,this is done by the lines

</p>
<font color="blue">
<pre>
if n is a leaf node{
    if the leaf is agoal node,return true
    else return false
}
</pre>
</font>
<p>The backtracking algorithm is simple but not important.You should understand it thoroughly.Another way to startingis it as follows</p>
<ul>
<li>To search a tree:</li>
</ul>
<ol>
<li>If the tree consist of a single leaf,test whether it is a goal Node.</li>
<li>otherwise, search the subtree until you find containing a goal node or until you have searcher  them unsuccessfully.</li>
</ol>
<h3>Non-recursive backtracking using slack</h3>
<p>Backtracking is rather typical resursive algorithm,and any recursive algorithm can be written as astack algorithm in fact,that is how your recursive are translated into a machine or assembly language

</p>
<font color="blue">
<pre>
    
 boolean solve(node n) 
    put node n on slack;
    while the slack is not empty{

    }
        if the node at the top of the stack in a leaf {
            if it is a goal node ,return true
            else pop it off the stack

        }
        else {
            if the node at the top of the stack has untried children
            push the next untried child onto the stack
            else pop the node off the stack
        }
        return false
    }

</pre>
</font>
<p>Starting from the root,the only node that can be pushed onto the stack are the childrenof node currently on the node of the slack, and these are only pushed on one child at a time; hence, the node on the stackat all time describe a valid path in the tree nodes are removed from the stacks only when it is know that they have no goal nodes among there descendents.</p>
<p>when the stack algorithmterminates successfully the nodes from the stack form(in reverse order)a path from the root to the goal node.</p>
<p>Similarly when the recursive algorithm finds a goal node, the path information id embodied (in reverse order) in the sequence of the recursive calls . Thus as the recursion inwinds, the path  can be recovered one node at time,by(for instance)  printing the node at a currnet level,or storing it on an array </p>
<p> Here is the recursive backtracking algorithm, modified slightly to print(in reverse order) the nodes along the successful path.</p>
<font color="blue">
<pre>
    boolean solve (Node n) {
        if n isna leaf node {
         if the leaf is a goal node {
        print n 
        return true
             }
             else return false
        }else{
            for each child c of n {
                if solved(c) succeedes {
                    print n
                    return true
                }
            }
            return false
        }
    }
</pre>
</font>
<h3\>keeping backtracking simple</h3>
<p>All of these versions of the backtracking algorithm are pretty simple, but when the applied to the real problem, they can be great pretty  cluttered up with the details. Even determining  whether the nodes is a leaf can be complex</p>
<p>for example, if the path represents a series of a moves in a chess endgame problem, the leaves are checkmates ans salemates solution</p>
<p>To keep the program clean, therefore, the test like this should  be burried in methods.In chess game, for example you could test whetherthe node is leaf by writing a<b>gameOver mmethod</b>(or you could even call it <b>isLeaf</b>). This method would encapsulate all the ugly details of figuring out whether any possible moves remain.</p>
<p>Notice that the backtracking algorithm require us to kept track, for each node on the current path, which of its children have been tried already (so we don't have to try them again). In the above code we make this look simple, by just saying <b>for each child c of n</b>.In reality, it may be difficult to figure out what the possible childern are , and there may be obvious way to step through them. In chess , for example a node can represent one arrangement of piece on a chessboard, and each child of that node can be represent the arrangement after some piece has made a legal move. How domyou find these childrens , and how do you keep track of which ones you've already examined? </p>
<p>The most straightforward way to keep track of which children of the node have been tried as been follows: Upon initial entry to the node (that is, when you first get there from above), make a list of all its children. As you try each child , take it off the list .When the list is empty ,there are no remaining untired children, and you can return "failure" . This is a simple approach ,but it may requires quite a lot of additional work.</p>
<p>THere isn a easier way to keep track of which children have been tried , if you can define an ordering  on the children . If there is an ordering, and you know which child  you just tried , you can determine whuch child to try next</p>
<p>For example, you might be able to the number of the <b>childern through n,</b> and try them in numerical order.Then waybif you have just tried <b>child k,</b>you know that you have already tried children <b>k+1</b> through<b>n.</b>Or, if you are trying to color a map with just four colours, you can always try <b>red first,then yellow,then green , then blue.</b>If child yellow fails ,you know to try child green next. If you are searching a maze , you can try choices in the order left , straight , right(<b>or perhaps north, east,south,west</b>.)</p>
<p>It isn't always easy to find a simple way to orderd a children of a node.<b>IN the chess game example,</b>you might number your pieces(or perhaps the square of the board) and try them in numerical order ; but in the additional each piece may also have serveral moves , and the must also be ordered. </p>

<h3>Example: Tree Search</h3>
<p>For starters, lets do the simplest possible example of backtracking which searching an actual tree .we will also the simplest kind off tree , a binary tree</p>
<p>A binary There is a data structure composed of nodes. One node is designated as the root node.Each node can reference(point to)zero one or two other nodes which are called its children.The children are referred to as the left child and/or the right child</p>
<p>here's the defination of BinaryTree class:</p>
<font color="blue">
<pre>
    public class BinaryTree {
        BinaryTree leftChild = null;
        BinaryTree rightChild= null;
        boollean isGoalnode  = false;
        String name,

        BinaryTree(String name,BinaryTree left, BinaryTree righg, boolean isGoalnode) {
            this.name = name;
            leftChild = left;
            this.isGoalNode = isGoalNode
        }
    }
</pre>
</font>
<p>Next we will create a TreeSearch class,and in we will define a method makeTree() which construct the above binary tree.</p>
<font color="blue">
<pre>
   static BinaryTree makeTree() {
    c= new BinaryTree("C",null,null,false);
    d= new BinaryTree("D",null,null,false);
    e= new BinaryTree("E",null,null,true);
    f= new BinaryTree("F",null,null,false);
    a= new BinaryTree("A",c,d,false);
    b= new BinaryTree("B",e,f,false);
    root=new BinaryTree(Root,a,b,false);
    return root;
   }
</pre>
</font>
<p>Here's main program to create a binary tree and try to solve it:</p>
<font color="blue">
<pre>
    public static void main(String args[]){
      BinaryTree tree = makeTree();
      system.out.println(solve(tree));
    }
</pre>
</font>
<p>And finally here's the recursive backtracking routine to "solve" the binary tree by finding a goal node</p>
<font color="blue">
<pre> 
    static boolean solvable (BinaryTree node) {

        /* 1 */ if (node == null) return false;
        /* 2 */ if (node.isGoalNode) return true;
        /* 3 */ if (solvable(node.leftChild)) return true;
        /* 4 */ if (solvable(node.rightChild)) return true;
        /* 5 */ return false;
    }
</pre>
</font>
<p>Here's what the number lines are doing:</p>
<li>If we are given a null node,it's not solvable. This statement is so that we can call this method with the children of a node first checking wether those children actually exist</li>
<li>If the node we are given is a goal node, return success.</li>
<li>See if the child oof the node is solvable, and if so, conclude that node is solvable.We will only get to this line if node is non-null and is not a goal node,says to</li>
<li>do the same thing for thenright child</li>
<li>Since neither childof node is solvable,node itself is notsolvable.</li>
<p>This program run correctly and produced the unenlightening result true.</p>
<p>Each time we ask a another node,we have to check if it is null.In the above we put the check at the first thing in solvable.An alternative would be to check whether each child exists ,and recur only if they do.Here's that alternative version</p>

<font color="blue">
<pre>
    static boolean solvable(BinaryTree node) {
        if (node.isGoalNode) return true;
        if(node.leftChild !=null && solvable(node.leftChild)) return true;
        if(node.rightChild !=null && solvable(node.rightChild)) return true;
        return false;
    }
</pre>
</font>

<p>I think the version simpler,but the second version is slightly more efficient.</p>
<h3> What are the children?</h3>
<p>one of the things that simplifies the above binary tree search is that,at each choice point, you can ignore all the previous choices don't give you any information about what you should do next,as far as you know,both the left and the right child are  possible solution in many problems,however,you may be able to eliminate children immediately without recursion.</p>
<P>Consider.for example, the problem of four coloring amap. It is a theorem of mathemaics that any map on a palne, no matter how convoluted the counteries are, can be coloredwithnat most fourcolors,so that no two countries that share a border are the same color.</P>
<p>To color a map you choose a color for the first country, then a color for the secondcountry as so on, until all countries are colored.</p>
<p>There are two ways to do this:</p>
<ol>
    <li> Method 1. Try each four possible color,and recur.When younrun out countries, check whether you are at goal node.</li>
    <li> Method 2 . try only those color that have not already been used for aan adjacent country, and recur.If and when you run out of countries, you have successfully colored the map.</li>
</ol>
<b>booleanmaplsOK()</b>
<P>Used by method 1 to check(at leaf node),whether the entire map is colored correctly.</P>
<b>boolean okToColor(int row,int column,int color)</b>
<P>Used by method 2 to check,at every node,whethere there is an adjacent node already colored with the given color.</P>
<b>int[] nextRowAndColumn(int row, int column)</b>
<P>Used by both methods to find the next "country"(actually,the row and the column of the next square on the checkboard).</P>
<p>Here's the code of method 1:</p>

<font color="blue">
<pre>
    boolean explore1(int row,int column,int color) {
        if(row >= NUM_ROW)return maplsOK();
        map[row][column]=color;
        for (int nextColor = Red; nextColor <= BLUE; nextColor++){
            int[] next = next RowAndColumn(row,column);
            if(explore1(next[0],next[1],nextColor)) return true;
        }
        return false;
    }
</pre>
</font>

<p>And here's the code for method 2:</p>

<font color="blue">
<pre>
    boolean explore2(int row,int column,int color) {
        if(row >= NUM_ROW)return true;
        if(okToColor(row,column,color)){
        map[row][column]=color;
        for (int nextColor = RED; nextColor <= BLUE; nextColor++){
            int[] next = next RowAndColumn(row,column);
            if(explore2(next[0],next[1],nextColor)return true;
        }
    }
    return false;
}
</pre>
</font>
<p>Those appear pretty similar, and you might think they are equally good. However, the timing information suggest otherwise:</p>


<!Doctype html>
<body>
<table align="center" width="">
    <thread>
        <tr>
            <th>  </th>
            <th>2 by 3 map</th>
            <th>3 by 3 map</th>
            <th>3 by 4 map</th>
        
        </tr>

    </thread>
   <tr>
        <td>Method 1:</td>
        <td>60 ms.</td>
        <td>940md.</td>
        <td>60530 ms (1 minute)</td>
   </tr>

        <tr>
            <td>Method 2:</td>
            <td>0 ms.</td>
            <td>0 ms.</td>
            <td>0 ms.</td>
        </tr>
    </table>
</body>
</body>




<p>The zero is in the above table,indicates time too shorty to measure(less then 1 millisecond).why this huge difference? Either of these method couldhave exponential growth. Eliminating a node automatically eliminates allits decendents, and this will often prevent exponential growth.Converselky, by watching to check untila leaf node is reached,exponential growth is practgically guaranteed. If there is any way to eliminate childrens(reduce the set of choices),do so!</p>
<h3>Debugging Techniques</h3>
<p>Often our first try at aprogram doesn't work, we need to debug it. Debuggers are helpful,but sometimes we need to fall back to inserting print statements.There are some simple tricks to making effective use of print statements.These tricks can be applied to any program, but are especially useful when you are trying to debug recursive routines.</p>
<p><b> Trick #1 INdent when you print method entires and exits.</b></p>
<p>Often,the best debugging techniques is to print every method call and return(or at least most important ones). You probably want to print , for each method ,what parameters it come in with,and what valueit leaves with.Howeverr,if you njust print along list of these</p>
<p><b> Trick #2 Used specialized print method for debugging.  </b></p>
<p>Don't clutter up ypur actual code more than , you  must also, rembember that code inserted for debugging purposes can itself contains bugs, or(in the worst case) can effect the results, so be carefully with it.</p>
<p>Here'sour debugging code</p>
<font color="blue">
    <pre>
        static String indent ="";


        static String name(BinaryTree node) {
         if (node == null ) retiurn null;
         else return node.name;
        }

        static void enter(BinaryTree node) {
        System.out.println (BinaryTree + "Entering solvable("+name(node)+ ")");
        indent = indent + "|";
        }
        static boolean yes(BinaryTree node) {
            indent = indent.substring (3);
            system.out.println(indent + "solvable("+ name (node)+ ")return true");
            return true;
        }
        static boolean no (BinaryTree node) {
            indent = indent.substring(3);
            system.out.println(indent+ "solvable("+ name(node)+") return false");
            return false;
        }

    </pre>
</font>
<p>To use this code, we mpodifly  solvable as follows:</p>
<font color ="blue">
<pre>
    static boolean solvable (BinaryTree node) {
        enter(node);
        if (node == null) return no(node);
        if (nod.isGoalNode ) return yes(node);
        if(solvable(node.left child))return yes (node);
        return no(node);
    }
</pre>
</font>

<p>And we get these result:</p>

<pre>
Entering solvable (Root)
 |Entering solvable(A)
 ||Entering solvable (C)
 |||Entering solvable (null)
 |||solvable (null) return false
 |||Entering solvable (null)
 |||solvable (null) return false
 ||solvable (C) return false
 ||Entering solvable (D)
 |||Entering solvable (null)
 |||solvable (null) return false
 |||Entering solvable (null)
 |||solvable (null) return false
 |||Entering solvable (null)
 ||solvable (D) return false
 |solvable (A) return false
 |Entering solvable (B)
 ||Entering solvable (E)
 ||solvable(E) return true
 |solvable(B) return true
 solvable(Root) return true
 true
</pre>

<p><b>Trick#3 Never disvharge your debugging statements.</b></p>
<p>Writing debugging statements programing,too. Often it's much work to debug the debugging statements as itis to debug the actual program.Once your program is working,why throw this code away?</p>
<p>Obviously, you don't want to print out all this debugging information from a program are you ready to submit (for the turn over to your manager ).You comment out your debugging calls,but that can belot of work. What's more,in the abovr example , you would have to return(node) with return(true),and every return(node) with return false, you might introduce new bug into your program.  </p>
<p>The simple solution is to make your debugging statements conditions.For example:</p>
<font color="blue">
    <pre>
        static final boolean debugging ="false";

        static void enter(BinaryTree node) {
            if (debugging){
            System.out.println (BinaryTree + "Entering solvable("+name(node)+ ")");
            indent = indent + "|";
            }
            static boolean yes(BinaryTree node) {
                if (debugging){
                indent = indent.substring (3);
                system.out.println(indent + "solvable("+ name (node)+ ")return true");
                }
                return true;
            }
        }
           static boolean no (BinaryTree node) {
            if(debugging){}
                indent = indent.substring(3);
                system.out.println(indent+ "solvable("+ name(node)+") return false");
              }
            return false;
            }
    
    </pre>
    </font>
<b> In industry actual programs often have multiple flags to control different aspects of debugging . don't worry too much about making your code larger; modern complier will notice that since the variable debugging is final debugging is final, it can never be true ,and the controlled code will be discarded.</b>

<p><b> Create an Exception.</b></p>
<p>If an Exception is throw , you can get information about just when it happened by sending the message printStackTrace (Printstream). Since an Exception in an object like any other , you can create and throw your own  Exception .However , Java programmer don;t always realize that you can create an Exception without throwing it. For example, the following code.  </p>
<font color ="blue">
    <pre> 
        new Exception("checkpoint Charlie").printStackTrace(System.out);
    </pre>
</font>
<p> will print out a message something like this , and the program will then continue normally. That's ,the Above code just acts like a print statement</p>
<font color="blue">
    <pre> 
        java.lang.Exception: checkpoint Charlie
        at TheSearch.solvable(TreeSearch,java:53)
        at TheSearch.solvable(TreeSearch,java:57)
        at TheSearch class.main (TreeSearch,java:72)
        at___SHELL38.run(___SHELL38.java:16)
        at bluej.runtime.Execserver.suspendedExecution(Unknown Source)SS



    </pre>
</font>
<h2>Example: Cindy's Puzzel</h2>
<p>I call the falling puzzel for historical areas. you jave some numbers of n of black marbels and the same number of white marbels and you have a palying board of aline of 2n+1 spaceto put the marbel in Start with the black marbles</p>
<tr>
<table align="center"> 
</tr>
<td>
    <table border ="1">
    <tr>
    <td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
    <td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>   
    <td width="40px"></td>     
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>       
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>      
    </tr>
    </table>
    </td>
</table>
    <p>The goal is to reverse the position of the marbles.</p>
    <tr>
     <table align="center">
     </tr>
    <td>
        <table border ="1">
        <tr>
        <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>       
        <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>
        <td width="40px"></td>   
        <td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
        <td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>   
             
        </tr>
    </td>
        </table>
    </table>
    <p><b>The black marbles can only use to the right and the white marble canonly move the left (no backing up). at each move,a marble can either: </b></p>
    <li>Move one space ahead, if that space is clear,or</li>
    <li>Jump ahead over exactlyone marble of opposite color,if the space just beyond that marble is clear.</li>

    <p>For example,you couldmake the following sequence of moves:</p>
    



<tr>
<table align="center"> 
</tr>
<td>Starting position:</td>
<td>
<table border ="1">
<tr>
<td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
<td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>   
<td width="40px"></td>     
<td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>       
<td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>      
</tr>
</table>

<tr>
<td>Black moves ahead</td>:</td>
<td>
<table border ="1">
<tr>
<td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></image></td>        
<td width="40px"></td>     
<td width="40px"><image src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></image></td>       
<td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>
<td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>     
</tr>
</table>
</td>
</tr>

<tr>
    <td>White jumps:</td>
    <td>
<table border ="1">
<tr>
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>   
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
    <td width="40px"></td>       
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>     
    </tr>
    </table>
    </td>
    </tr>
 
    
    <tr>
        <td>Black moves ahead:</td>
        <td>
<table border ="1">
    <tr>
        <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
        <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>   
        <td width="40px"></td>     
        <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>       
        <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>     
        </tr>
        </table>
        </td>
        </tr>
 
        
        <tr>
            <td>Black jumps:</td>
            <td>
    <table border ="1">
        <tr>
            <td width="40px"></td>     
            <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>   
            <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
            <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>       
            <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>     
            </tr>
            </table>
            </td>
</tr>
           
<tr>
    <td>White moves a head:</td>
    <td>
<table border ="1">
<tr>
    <td width="40px"></td>     
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>   
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>     
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\e53bd6e9-ab43-47d5-a670-438f1da565a1.png" alt=""></td>       
    <td width="40px"><img src="C:\Users\Hp\Desktop\backtracking.html\.vscode\c6608ff1-eb1d-4c93-83c8-4feefe5b96eb.png" alt=""></td>     
    </tr>
    </table>
    </td>

    <tr>
        <td>Stuck!</td>
    </tr>
</table>



<p>The backtracking maethod is named solvable and return boolean.In solvable we shll need to check whether we are not a leaf , which in the case meansposition from which no further moves are possible.This isn;t so easy.</p>
<p>Now to the program . the main progaram will initialize board, and call a recursive backtracking routineto attempt a solve the puzzel.</p>
<p>The backtracking maethod is named solvable and return boolean.In solvable we shll need to check whether we are not a leaf , which in the case meansposition from which no further moves are possible.This isn;t so easy.</p>
<p>Each possible moves will result in a new board, and these new board possitions are children of  the current board position</p>
<p>Here is time to and stop take through. To make progress, we must analyze the game to some extent.Probably a number ofapproach would work,and follows</p>
<p><b>Now we have ordering of a moves to use in our program . Just check, In order,the 2n+1 spaces of the board. For each space, either zero or one moves is possible. With this understanding ,we can write aboolean method canMove in(int[] board, int position ) which determines whether a move is possible for the given position:</b></p>
<li> If the position is empty, no moves is possible;</li>
<li>If the possitions contains a black marbles,the method check for a move or jump to the right;</li>
<li>If the position contains the white marbles,the method checks for a jump to the left.</li>

<p>We write another method <b>int[] makeMove(int[] oldBoard,int position)that will take aboard and a position, make a move from that position , and return and its value a new board.(We could write this somewhat more efficiently by changing the old board,rather than creating a new one, but here we are more concerned with simplicity).In the technical jargon, makeMove is "applicative" rather than "mutative".</p>
    <p>Along with <b>canMove and makeMove,</b> we are using methods<b>puzzelsSolve and printBoard</b>with meaning that should be obvious.</p>
    <font color="blue">
    <pre>
        boolean solvable(int[]board){
            if(puzzelSolve(board)){
                return true;
            }
        for(int position=0 ; position < BOARD_SIZE;position++){
           if(canMove(board,position)){
            int[]newBoard =  makeMove(board,position);
            if(solvable(newBoard)){
            printBoard(newBoard);
            return true;
           }
        }
    }
    return false;
}

    </pre>
    </font>
<br>
    <P>Along with canMove and makeMove,we are using methods puzzleSolved with meaning that should be obvious. </P>
    <p>Here is some output from the program:</p>
    <br>
    <pre>
    <ol reversed="16">
    <li>WHITE WHITE WHITE _____ BLACK BLACK BLACK</li>
    <Li>WHITE WHITE WHITE BLACK _____ BLACK BLACK</Li>
    <Li>WHITE WHITE _____ BLACK WHITE BLACK BLACK</li>
    <li>WHITE _____ WHITE BLACK WHITE BLACK BLACK</li>
    <li>WHITE BLACK WHITE _____ WHITE BLACK BLACK</li>
    <li>WHITE BLACK WHITE BLACK WHITE _____ BLACK</li>
    <li>WHITE BLACK WHITE BLACK WHITE BLACK _____</li>
    <li>WHITE BLACK WHITE BLACK _____ BLACK WHITE</li>
    <li>_____ BLACK WHITE _____ BLACK BLACK WHITE</li>
    <Li>BLACK BLACK WHITE BLACK _____ BLACK WHITE</Li>
    <Li>BLACK BLACK _____ BLACK WHITE BLACK WHITE</li>
    <li>BLACK _____ WHITE BLACK WHITE BLACK WHITE</li>
    <li>BLACK BLACK WHITE _____ WHITE BLACK WHITE</li>
    <li>BLACK BLACK WHITE BLACK WHITE BLACK WHITE</li>
    <li>BLACK BLACK _____ BLACK WHITE WHITE WHITE</li>
    <li>BLACK BLACK BLACK _____ WHITE WHITE WHITE</li>
</ol>
      </pre> 
      <p>Notice that the solution is given order: BLACK starts out on the left and WHITE on the right , as in the last line.I've added line numbers to the actual output in order to emphasize this point .Backtracking always produces its results (sequence of choices) in reverse order ; it is up to you , the programmer , to reverse result again to get</p>